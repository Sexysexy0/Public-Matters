// SPDX-License-Identifier: MIT
pragma solidity ^0.8.21;

/// @title BrowserVulnerabilityLedger
/// @notice Registry for browser CVEs, breach severity, and patch compliance
/// @dev Anchors emotional APR tagging and civic audit events for browser security

contract BrowserVulnerabilityLedger {
    address public steward;
    mapping(address => bool) public auditors;

    modifier onlySteward() {
        require(msg.sender == steward, "Not steward");
        _;
    }

    modifier onlyAuditor() {
        require(auditors[msg.sender] || msg.sender == steward, "Not auditor");
        _;
    }

    enum Severity {
        Low,
        Moderate,
        High,
        Critical
    }

    enum PatchStatus {
        Unpatched,
        Patched,
        Verified
    }

    struct CVE {
        uint256 id;
        string cveCode;
        string browser;
        string version;
        Severity severity;
        string description;
        PatchStatus status;
        string emotionalTag;
        uint256 createdAt;
        uint256 updatedAt;
    }

    uint256 public nextCveId = 1;
    mapping(uint256 => CVE) public cveRegistry;
    mapping(string => uint256[]) public browserCveIds;

    event AuditorSet(address indexed account, bool status);
    event CVEFiled(uint256 indexed id, string browser, string version, Severity severity);
    event PatchStatusUpdated(uint256 indexed id, PatchStatus status, string emotionalTag);
    event PatchComplianceVerified(uint256 indexed id, string browser, string version);

    constructor() {
        steward = msg.sender;
        auditors[msg.sender] = true;
        emit AuditorSet(msg.sender, true);
    }

    function setAuditor(address account, bool status) external onlySteward {
        auditors[account] = status;
        emit AuditorSet(account, status);
    }

    function fileCVE(
        string calldata cveCode,
        string calldata browser,
        string calldata version,
        Severity severity,
        string calldata description
    ) external onlyAuditor returns (uint256 id) {
        id = nextCveId++;
        cveRegistry[id] = CVE({
            id: id,
            cveCode: cveCode,
            browser: browser,
            version: version,
            severity: severity,
            description: description,
            status: PatchStatus.Unpatched,
            emotionalTag: "",
            createdAt: block.timestamp,
            updatedAt: block.timestamp
        });
        browserCveIds[browser] = append(browserCveIds[browser], id);
        emit CVEFiled(id, browser, version, severity);
    }

    function updatePatchStatus(uint256 id, PatchStatus status, string calldata emotionalTag) external onlyAuditor {
        CVE storage cve = cveRegistry[id];
        require(cve.id != 0, "CVE not found");
        cve.status = status;
        cve.emotionalTag = emotionalTag;
        cve.updatedAt = block.timestamp;
        emit PatchStatusUpdated(id, status, emotionalTag);
        if (status == PatchStatus.Verified) {
            emit PatchComplianceVerified(id, cve.browser, cve.version);
        }
    }

    function getCVE(uint256 id) external view returns (CVE memory) {
        return cveRegistry[id];
    }

    function listBrowserCVEs(string calldata browser) external view returns (uint256[] memory) {
        return browserCveIds[browser];
    }

    function append(uint256[] memory arr, uint256 value) internal pure returns (uint256[] memory) {
        uint256[] memory newArr = new uint256[](arr.length + 1);
        for (uint256 i = 0; i < arr.length; i++) {
            newArr[i] = arr[i];
        }
        newArr[arr.length] = value;
        return newArr;
    }
}
